---
layout: post
title: Relative and absolute paths in Linux
comments: true
tags:
  - linux
  - data management
---

Paths is a topic that causes a lot of confusion for people that want to learn
how to make use of the command line in Linux. In this post I will explain 
what paths are, the difference between absolute and relative paths, how
relative paths can be used to make scripts more portable, and how relative
paths can be used to improve your data management.

The term "path" refers to the name of a file or directory that can used to
uniquely identify it in you computer. For example, the command ``pwd`` prints
the name of the current working directory.

```
$ pwd
/home/olssont
``` 

In the above ``/home/olssont`` is the path to the directory that I am currently
in. To illustrate this further we can create a file in this directory. The
command below creates a file named ``raw_data.txt``. 

```
$ echo "Raw data generated by my stream of consciousness" > raw_data.txt
```

We can see the files in he working directory using the command ``ls``.

```
$ ls
raw_data.txt
```

Depending on how many files you have in your working directory you may see more
output from the command above.

To print the content of the file one can use the command ``cat``.

```
$ cat raw_data.txt
Raw data generated by my stream of consciousness
```

In the above the text ``raw_data.txt`` could be used to find the file that we
just created. This was because the file was present in the working directory.

So how can we refer to a file if it is not present in the working directory?
This is where the use of absolute and relative paths come into play.

To illustrate this we will use the command ``mkdir`` to create a new directory
called ``raw_data``.

```
$ mkdir raw_data
```

Then we will use the command ``mv`` to move the file into that directory.

```
$ mv raw_data.txt raw_data/
```

Before illustrating the correct way to refer to the file let's illustrate
what happens if we use the same command as previously.

```
$ cat raw_data.txt
cat: raw_data.txt: No such file or directory
```

The ``cat`` command is no longer able to find the file. There are two methods
that you could use to refer to the file in the raw_data directory. The first is
to use an absolute path, in this case ``/home/olssont/raw_data/raw_data.txt``.
Note that the absolute path to your file will be different if your username is
different to mine and/or if you are not working in your home directory.

```
$ cat /home/olssont/raw_data/raw_data.txt
Raw data generated by my stream of consciousness
```

The second method is to make use of a relative path, that means a path that
is relative to your current working directory, in this case ``raw_data/raw_data.txt``.
The forward slash (``/``) is the symbol used to separate directories and files.

```
$ cat raw_data/raw_data.txt
Raw data generated by my stream of consciousness
```

A different way to represent this relative path is to prepend it with ``./``, where
the dot is a symbol that is used to represent the current working directory. Some
people prefer this way because it makes it easer to see that it is a relative path.


```
$ cat ./raw_data/raw_data.txt
Raw data generated by my stream of consciousness
```

To illustrate the concept of relative paths further we will create another
directory called ``scripts``.

```
$ mkdir scripts
```

Now we will change our working directory to be ``scripts`` using the ``cd``
(change directory) command.

```
$ cd scripts
```

Let us see what happens if we run the previous ``cat`` command again (you
should be able to get back to this by using the up and down arrows on your
keyboard to navigate through the command line history).

```
$ cat ./raw_data/raw_data.txt
cat: ./raw_data/raw_data.txt: No such file or directory
```

The command above fails because it expects to be able to find a directory named
``raw_data`` in the current working directory and because we have moved into
the ``scripts`` directory there is no such directory. In order to be able to
make this work we need to be able to specify that we want to go down one level in
the directory tree. This can be achieved using double dots, i.e. using the
prefix ``../``. To refer to something two levels down in the directory tree one
would use the prefix ``../../``, and so forth.

```
$ cat ../raw_data/raw_data.txt
Raw data generated by my stream of consciousness
```

To summarise:

- Paths are used to be able to refer to unique files
- An absolute path starts at the top of the directory tree and includes all
  parent directories separated by slashes as well as the file/directory of
  interest. Examples of absolute paths include ``/home/olssont`` (a directory),
  ``/home/olssont/raw_data/raw_data.txt`` (a file)
- Relative paths are used to refer to files and directories with respect to the
  current working directory
- In a relative path the prefix ``./`` means the current working directory,
  the prefix ``../`` means the parent directory, and the prefix ``../../``
  means the parent's parent directory, and so forth

This should be enough to get you started with the Linux command line and you
can stop reading here and make yourself a cup of coffee and be merry. &#128515;

So what is better absolute or relative paths, which one should be used when
one needs to refer to a file in a script? Let me prefix my answer with the 
caveat that paths are a pain. However, absolute paths are more of a pain than
relative paths. This is because absolute paths make it difficult to restructure
the way that directories are organised on your computer. They also make it
difficult for you to share your scripts with collaborators because they would
need their computer to be structured in exactly the same way as yours. It is
possible to get around some of these issues by using relative paths.

To illustrate the use of relative paths in scripts create a file named
``analysis.sh`` in your ``scripts`` directory, i.e. with the relative path
``./scripts/analysis.sh``, and copy and paste the code below into it.

```bash
#!/bin/bash

# Save the current working directory before changing
# into the scripts directory.
PREVIOUS_WORKING_DIRECTORY=$(pwd)

# This line changes to current working directory to where
# the analysis.sh file is.
cd "$(dirname "$0")"

# Create a directory for derived data if it does not already exist.
DERIVED_DATA_DIRECTORY=../derived_data
mkdir -p $DERIVED_DATA_DIRECTORY

# This line streams the content of the raw data file into the sed
# stream editor that replaces the word Raw with Derived. Finally,
# the output of the sed command is redirected to a derived_data.txt
# file in the derived data directory.
cat ../raw_data/raw_data.txt  \
        | sed -e s/Raw/Derived/  \
        > $DERIVED_DATA_DIRECTORY/derived_data.txt

# Go back to where we were before changing into the
# scripts directory.
cd $PREVIOUS_WORKING_DIRECTOR
```

The code above works with relative paths. The paths are relative to the
``scripts`` directory. That means that outcome of the script will be
independent of the directory one is in when running the script, i.e.  no nasty
side effects of input files not being found or output files being written to
the wrong directory.

To achieve this the script first makes a note of the directory you are
currently in and stores it in the ``PREVIOUS_WORKING_DIRECTOR`` environment
variable. The script then changes the working directory to be that of the
``analysis.sh`` script. At this point the script can start working with paths
relative to the ``scripts`` directory.

The details of the analysis in this script do not really matter. It creates a
directory for derived data (``../derived_data``) if it does not already exist.
It then takes as input the raw data, transforms it before writing it to a file
in the derived data directory.

Finally, and importantly, the script changes the working directory back to
whatever it was before the script was invoked.

To test the script we can go back to the top level directory.

```
cd /home/olssont
```

In the above I'm using an absolute path to make it clear which directory I am
referring to. Depending on your setup this path may be different. For clarity,
I am referring to the directory in which you created the ``raw_data`` and
``scripts`` directories.

Before we run the script we need to use the ``chmod`` command to make it
executable.

```
chmod +x ./scripts/analysis.sh
```

We can then run the script by calling its path.

```
./scripts/analysis.sh
```

This will have created a directory called ``dervied_data`` at the same level
as the ``scripts`` directory.

```
$ ls
derived_data  raw_data  scripts
```

Let us also use the ``cat`` command to look at the content of the
``./derived_data/derived_data.txt`` file.


```
$ cat ./derived_data/derived_data.txt
Derived data generated by my stream of consciousness
```


In a [previous post]({% post_url 2019-02-26-data-management-for-biologists %}])
about data management I talked about the need to keep raw data separate from
derived data. In this post I have given you some tips on how you can accomplish
this. Setting up scripts in the fashion outlined above also has the benefit
that it is easier to rename and reorganise directories without your scripts
breaking. Furthermore, it will make it easier for you to share your scripts
with collaborators.
